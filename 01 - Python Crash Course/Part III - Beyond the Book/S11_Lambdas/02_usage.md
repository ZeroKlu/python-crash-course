## Using Lambdas vs Functions

There are lots of different ways to use lambda functions, and it's worth
exploring them even if only to cement the previous definitions.

---

### Higher Order Functions

A higher-order function is one that takes another function (or of course
a lambda) as an argument.

Python has many built-in higher-order functions that expect a lambda as
an argument, including:

* `map()`
* `filter()`
* `functools.reduce()`
* `sort()`
* `sorted()`
* `min()`
* `max()`
* etc.

Here is a simple example of a higher-order function:

```python
def higher_order_function(x: int, func: callable) -> int:
    """Returns `x` plus result of `func(x)`"""
    return x + func(x)
```

We can define the same thing as a lambda

```python
higher_order_lambda = lambda x, func: x + func(x)
```

Calling either one, we can use another lambda as the argument for the
`func` parameter:

```python
x = 2
print(higher_order_function(x, lambda y: y ** 2))
print(higher_order_lambda(x, lambda y: y ** 2))
```

Output:

```
6
6
```

---

### Comparing a Function with Its Equivalent Lambda

The `dis` library allows us to view the resulting bytecode when Python
performs just-in-time compilation.

Let's create a function that performs the same task two ways: once with
and once without using a lambda.

```python
import dis

def add_function(x: int, y: int) -> int:
    """Add two numbers"""
    return x + y

def compare_bytecode() -> None:
    """Examine the bytecode generated by a function versus a lambda"""
    print("\nAnalyzing add_function...")
    print(f"Type: {type(add_function)} ({add_function})")
    dis.dis(add_function)

    print()

    add_lambda = lambda x, y: x + y

    print("\nAnalyzing add_lambda...")
    print(f"Type: {type(add_lambda)} ({add_lambda})")
    dis.dis(add_lambda)

compare_bytecode()
```

Output:

```
Analyzing add_function...
Type: <class 'function'> (<function add_function at 0x0000023DAA7356C0>)
  7           0 RESUME                   0
  9           2 LOAD_FAST                0 (x)
              4 LOAD_FAST                1 (y)
              6 BINARY_OP                0 (+)
             10 RETURN_VALUE

Analyzing add_lambda...
Type: <class 'function'> (<function compare_bytecode.<locals>.<lambda> at 0x0000023DAA734F40>)
 20           0 RESUME                   0
              2 LOAD_FAST                0 (x)
              4 LOAD_FAST                1 (y)
              6 BINARY_OP                0 (+)
             10 RETURN_VALUE
```

We can see that both the function and the lambda compile down to the
exact same bytecode.

---

### Comparing Function Errors against Equivalent Lambda

We can also check to determine that exceptions raised by functions and
their equivalent lambdas are identical:

```python
import traceback

def compare_errors() -> None:
    """Examine the errors generated by a function versus a lambda"""
    x = 2
    y = 0

    try:
        print("\nError in function...")
        print(divide_function(x, y))
    except:
        print(traceback.format_exc())

    print("\n-----\n")

    divide_lambda = lambda x, y: x / y
    
    try:
        print("\nError in lambda...")
        print(divide_lambda(x, y))
    except:
        print(traceback.format_exc())

compare_errors()
```

Output:

```
Error in function...
Traceback (most recent call last):
  File "...\02_lambda_usage.py", line 40, in compare_errors
    print(divide_function(x, y))
          ^^^^^^^^^^^^^^^^^^^^^
  File "...\02_lambda_usage.py", line 29, in divide_function
    return x / y
           ~~^~~
ZeroDivisionError: division by zero


-----


Error in lambda...
Traceback (most recent call last):
  File "...\02_lambda_usage.py", line 49, in compare_errors
    print(divide_lambda(x, y))
          ^^^^^^^^^^^^^^^^^^^
  File "...\02_lambda_usage.py", line 45, in <lambda>
    divide_lambda = lambda x, y: x / y
                                 ~~^~~
ZeroDivisionError: division by zero
```

---

